#!/usr/bin/env perl
#
# Author: Guillermo Ramos <gramos@gramos.me> (2019)
#
# Run `tgrecv -h` for quick help, or `tgrecv -h -v` for full manual.
#
# Dependencies: HTTP-Message, JSON
################################################################################

$main::VERSION = "0.1.0";

use Getopt::Long qw(:config auto_version);
use Pod::Usage qw<pod2usage>;
use LWP::UserAgent;
use Data::Dumper;
use Storable qw<store retrieve>;
use File::Basename qw<dirname>;

use HTTP::Request;
use JSON qw<encode_json decode_json>;


my $HOME = $ENV{'HOME'};
my $CONFIG_HOME = $ENV{'XDG_CONFIG_HOME'} || "$HOME/.config";
my $CACHE_HOME = $ENV{'XDG_CACHE_HOME'} || "$HOME/.cache";

my $cache;

my $TOKEN;
my $OUTPUT;
my $OFFSET;
my $AUTO_OFFSET;
my $TIMEOUT = 60;
my $VERBOSE = 0;
my $HELP;

GetOptions("token=s" => \$TOKEN,
           "offset=i" => \$OFFSET,
           "auto-offset" => \$AUTO_OFFSET,
           "timeout=i" => \$TIMEOUT,
           "output=s" => \$OUTPUT,
           "verbose+" => \$VERBOSE,
           "help" => \$HELP);
pod2usage(-verbose => $VERBOSE+1) if $HELP;

# If token was not specified in CLI, try to get it from ENV
$TOKEN ||= $ENV{'TGUTILS_TOKEN'};

# If still no token, try to get it from ~/.config/tgutils_token
unless ($TOKEN) {
    my $CONFIG = "$CONFIG_HOME/tgutils_token";
    open(my $cfg, "<", $CONFIG) or
        pod2usage(-message => "ERROR: Unable to get bot token ($CONFIG: $!).\n",
                  -verbose => 99, -sections => "AUTHENTICATION");
    $TOKEN = <$cfg>;
    chomp $TOKEN;
    close $cfg;
}

# Sanity check
$TOKEN =~ /^[0-9]+:[a-zA-Z0-9]+$/ or die "Invalid bot token ($TOKEN)";

# Fetch cache (TODO move to module)
my $CACHE_FILE = "$CACHE_HOME/tgutils/cache";
$cache = -f $CACHE_FILE
    ? retrieve($CACHE_FILE)
    : {'version' => $main::VERSION};
print STDERR "Using cache:\n", Dumper($cache), "\n" if $VERBOSE > 1;

# Get offset from cache if --auto-offset is enabled (and no --offset provided)
if ($AUTO_OFFSET && ! $OFFSET) {
    $OFFSET |= $cache->{'offset'};
}

my $ua = LWP::UserAgent->new;
my $uri = "https://api.telegram.org/bot$TOKEN/getUpdates?timeout=$TIMEOUT";
$uri = $uri . "&offset=$OFFSET" if $OFFSET;
my $req = HTTP::Request->new("GET", $uri);
if ($VERBOSE) {
    print STDERR "Request:\n", Dumper($req), "\n" if $VERBOSE > 1;
}

my $resp = $ua->request($req);
print STDERR "Response:\n", Dumper($resp), "\n" if $VERBOSE > 1;
if ($resp->is_error()) {
    die $resp->message;
} else {
    my $out = STDOUT;
    if ($OUTPUT) {
        open($out, ">", $OUTPUT) or die "Cannot open $OUTPUT for writing: $!";
    }
    my $results = decode_json($resp->content)->{'result'};

    # Store new offset in cache
    if ($AUTO_OFFSET && @$results) {
        printf STDERR "Setting new offset to %s (--auto-offset)\n",
            $cache->{'offset'} if $VERBOSE > 1;
        # Update cache: set offset to last update id +1
        $cache->{'offset'} = $results->[-1]->{'update_id'}+1;
        # Save cache (TODO move to module)
        mkdir dirname $CACHE_FILE;
        store($cache, $CACHE_FILE);
    }

    print $out encode_json($results);
}



__END__

=head1 NAME

tgrecv - Receive updates from Telegram, output them as JSON

=head1 SYNOPSIS

tgrecv [-h | --help]

tgrecv [options]

=head1 OPTIONS

  --offset            Offset of the first message to receive - previous ones are
                      discarded
  --auto-offset       Use offset cache to automatically discard previous updates
                      (if combined with --offset, cache the last update but
                      still use the provided offset for the current request)
  --timeout           Timeout for long polling (default: 60 seconds)
  --output=file       Write the output to file instead of stdout
  --token | -t        Bot token (see AUTHENTICATION)
  --version           Show version
  --verbose | -v      Show more information (combine with -h to see full manual)
  --help | -h         Show this message

=head1 DESCRIPTION

This program receives a single update batch from the Telegram bot identified by
B<token>, and outputs it as a JSON array. The array can contain multiple
updates. The connection is blocking (long polling), so it waits until an update
is available before exiting.

=head1 AUTHENTICATION

To get the bot token, this program will check (in order):

  - The "--token" CLI argument
  - The "TGUTILS_TOKEN" environment variable
  - The contents of "$XDG_CONFIG_HOME/tgutils_token"
    (usually ~/.config/tgutils_token)

=cut
